# 스택과 큐의 핵심 이론

스택과 큐는 리스트에서 좀 더 발전한 형태의 자료구조이다. 스택과 큐는 구조는 비슷하지만 처리 방식이 다르다.

## 스택

스택은 삽입과 삭제 연산이 후입선출(LIFO: Last In First Out)로 이뤄지는 자료구조이다. 즉, 후입선출은 한 쪽에서만 삽입과 삭제가 일어난다.

- 스택은 깊이 우선 탐색(Depth First Search), 백트래킹 종류의 코딩 테스트의 효과적이므로 반드시 알아두어야 한다.
- 후입선출은 개념 자체가 재귀 함수 알고리즘 원리와 일맥상통하기 때문이다.

### 위치

- top: 삽입과 삭제가 일어나는 위치를 뜻한다.

### 연산

- `s.append(data)`: **top 위치**에 새로운 데이터를 삽입하는 연산
- `s.pop()`: **top 위치**에 현재 있는 데이터를 삭제하고 확인하는 연산
- `s[-1]`: **top 위치**에 현재 있는 데이터를 단순 확인하는 연산

## 큐

큐는 삽입과 삭제 연산이 선입선출(FIFO: First In First Out)로 이뤄지는 자료구조이다. 스택과 다르게 먼저 들어온 데이터가 먼저 나간다. 그래서 양방향에서 삽입과 삭제가 일어난다.

- 너비 우선 탐색(BFS: Breath First Search)에서 자주 사용된다.

### 위치

- rear: 큐에서 가장 끝 데이터를 가리키는 영역
- front: 큐에서 가장 앞의 데이터를 가리키는 영역

### 연산(리스트 이름:s)

파이썬에서는 일반적으로 deque를 이용하여 큐를 구현한다.

- `s.append(data)`: **rear 부분**에 새로운 데이터를 삽입하는 연산
- `s.popleft()`: **front 부분**에 데이터를 삭제하고 확인하는 연산
- `s[0]`: **큐의 맨 앞(front)**에 있는 데이터를 확인할 때 사용하는 연산

### 💡 우선순위 큐란 ?

> 들어간 순서에 상관없이 우선순위가 높은 데이터 먼저 나오는 자료구조이다. 큐 설정에 따라 front에 항상 최댓값 또는 최솟값이 위치한다. 우선순위 큐는 일반적으로 힙을 이용해 구현하는데 힙은 트리 종류 중 하나이다. 06장 참고!


# deque()와 list()의 시간복잡도 개념
양끝을 사용한다면 상관없지만 fron-rear 개념이 있다면 (즉, 왼쪽을 변경해야한다면) deque을 사용하는 것이 좋다.
```python
from collections import deque

N = int(input())

que = deque(range(1, N + 1))

while len(que) >1:
    que.popleft()
    que.append(que.popleft())

print(que[0])


# queue = list(range(1, N + 1))

# while 1 < len(queue):
#     queue.pop(0)
#     queue.append(queue.pop(0))

# print(queue[0])
```

## deque
이중 연결 리스트(doubly linked list) - **양쪽 끝에서 빠른 삽입과 삭제가 가능**
- 인덱싱(Indexing)
  - 배열이 아니라 연결리스트 이므로 특정 인덱스에 접근혀려면 앞 또는 뒤에서 순차적으로 요소를 찾아야 한다. 
    - 따라서, 시간복잡도 O(n)
- 삽입과 삭제(Insertion and Deletion)
  - 양쪽 끝에서의 삽입과 삭제
    - 데크는 양쪽 끝에서의 삽입`append()`, `appendleft()`과 삭제`pop()`, `popleft()`가 O(1) 시간 복잡도를 가진다. 
    - 이는 **끝 요소와의 연결만 변경하면 되기 때문**이다.
  - 중간에서의 삽입과 삭제
    - 중간에서의 삽입과 삭제는 리스트와 마찬가지로 O(n) 시간이 소요된다. 
    - 하지만 데크는 주로 양쪽 끝에서의 빠른 삽입과 삭제를 위해 사용된다.
    
## list 
python의 리스트는 **동적 배열(dynamic array)**
- 인덱싱(Indexing)
  - 리스트는 배열처럼 각 요소가 연속적인 메모리 공간에 저장된다. 따라서 특정 인덱스에 접근하는 데 O(1) 시간 복잡도를 가진다.
- 삽입과 삭제(Insertion and Deletion)
  - 끝에서의 삽입과 삭제
    - 리스트의 끝에서 삽입`append()`과 삭제`pop()`는 평균적으로 O(1) 시간 복잡도를 가진다. 
    - 이는 추가할 공간이 있으면 단순히 끝에 요소를 추가하거나 제거하면 되기 때문
  - 중간에서의 삽입과 삭제
    - 리스트의 중간에서 삽입하거나 삭제하려면 해당 위치 이후의 모든 요소를 이동해야 한다. 
    - 따라서 최악의 경우 O(n) 시간이 소요된다.
- 메모리 재할당
  - 리스트는 동적 배열이기 때문에 저장 공간이 꽉 차면 새로운 더 큰 배열로 복사해야 한다. 
  - 이는 비용이 많이 드는 작업으로, 최악의 경우 O(n) 시간이 소요될 수 있지만, 평균적으로는 O(1) 시간이다(이진법 분할 원리로 인해).